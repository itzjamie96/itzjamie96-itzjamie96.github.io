{"pages":[{"title":"About","text":"☕ + 🍰 = 👩💻 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"}],"posts":[{"title":"[Git] Repository 합치기 (commit history 포함)","text":"작년부터 자바를 위주로 공부해오다가 최근부터 본격적으로 파이썬을 공부하게 되었다. 파이썬 공부를 위해 GitHub에서 repository를 새로 생성하려다가, 오랜만에 내가 그동안 생성한 repo들을 보게 되었는데 아주 중구난방이었다. 공부를 하다만 기록들이 넘쳐났는데, 이참에 repo들을 정리할 겸 비슷한 내용의 repo들을 합치기로 했다. *repo = repository 합치기 전 확인할 것들 합친 프로젝트들을 보관할 새로운 repo 생성하기 합칠 프로젝트들 사이에 충돌이 일어날 수 있는 요소들 정리하기 (EX: 똑같은 이름의 폴더, readme.md 등) repo 안에 합쳐질 프로젝트 구조에 맞게 폴더 정리해두기. 구조를 미리 생각해놓는 것은 중요하다. 안그러면 한 repo에 뒤죽박죽 합쳐진 것들이 섞일 것이다. 내가 원한 폴더 구조: Repository 합치기(Merge) 신규 repository 생성먼저 합칠 새로운 repo를 생성한다 (git init도 해준다). 편의상 NEW repo라고 하겠다. 나는 Java로 자료구조와 알고리즘 연습하던 각각의 두 repo를 합치기로 결정했기 때문에, 누가봐도 Java의 자료구조와 알고리즘을 위한 repo라는 것을 나타낼 수 있는 이름의 repo를 새로 만들었다. 합칠 repository 정리합치기 전 확인할 부분에서 언급했듯이, merge하고자 하는 repo들을 좀 정리할 필요가 있다. 왜 그런지는 뒤에 나온다. 우선 편의상 내가 합치고자 하는 repo들을 OLD 1, OLD 2 repo라고 하겠다. repository 연결NEW repo의 위치 (C:\\Git\\Java-DataStructure-and-Algorithms&gt;에서 OLD repo들을 remote로 추가해준다. 12git remote add DataStructure-and-Algorithms-in-Java https://github.com/itzjamie96/DataStructure-and-Algorithms-in-Java.gitgit remote add Problem-Solving https://github.com/itzjamie96/Problem-Solving.git 기존 repository에서 데이터 가져오기각 OLD repo에서 fetch를 통해 원격 저장소의 데이터를 가져온다. 12git fetch DataStructure-and-Algorithms-in-Java mastergit fetch Problem-Solving master 합치기 (Merge)NEW와 OLD repo 들을 merge한다. 이 때 모든 commit history도 가져오기 위해 --allow-unrelated-histories를 해준다. 123456git merge --allow-unrelated-histories DataStructure-and-Algorithms-in-Java/master↓ 결과 ↓CONFLICT (add/add): Merge conflict in README.mdAuto-merging README.mdAutomatic merge failed; fix conflicts and then commit the result. 먼저 OLD 1을 합쳤더니 readme에서 conflict가 떴다 (이래서 합치기 전에 리드미를 없애던가 수정하던가 해야하는 것…) 우선 나는 리드미에 별 내용이 없었기 때문에 add 후 commit을 강행했다 (근자감). push까지 완료한 후 GitHub를 가보니… 생각보다 끔찍한 모양새는 아니었다. OLD 2를 합치기 전에 리드미를 지운 후 합쳐보기로 했다. 그 후 다시 합치기 시작! 1234567git merge --allow-unrelated-histories Problem-Solving/master↓ 결과 ↓CONFLICT (add/add): Merge conflict in .gitignoreAuto-merging .gitignoreAutomatic merge failed; fix conflicts and then commit the result. ^^…이번엔 .gitignore에서 문제가 생겼다…왜 자동으로 merge를 해주지 않는거야 git? 한 줄이던데… 간단한 수정 후 합치기 진행! 123git add .git commit -m \"MERGED REPOSITORIES\"git push origin master 완료!! repository 연결 해제마지막으로 혹시라도 기존의 repo들을 건들지 않도록 remote를 끊어준다. 12git remote remove DataStructure-and-Algorithms-in-Javagit remote remove Problem-Solving 다 끝난 후 GitHub에서 확인을 해봤다. 음 아주 잘됐군! 그저 파일만 합쳐진 것이 아니라 기존의 repo들에서 commit 기록까지 모두 잘 따라왔다. 끝! ReferenceCombining Repositories document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/07/20/github-how-to-merge-repositories/"},{"title":"[Java] 스택(Stack)","text":"스택 (Stack)Stack은 제한적으로 접근할 수 있는 구조다. 한 쪽 끝에서만 데이터를 넣거나 뺄 수 있는 구조로, 가장 나중에 넣은 데이터를 가장 먼저 빼낼 수 있다. 이게 바로 LIFO: Last In First Out 자료구조다. 가장 대표적인 예시는 프링글스인 것 같다. 윈기둥 형태의 프링글스 통에는 과자가 빽빽히 들어있다. 과자를 한 조각 꺼내 먹으려면 맨 위에 있는 조각부터 꺼내게 된다. 통에 가장 처음 넣어진 과자는 바닥 쪽에 있고, 맨 마지막으로 통에 넣어진 조각이 가장 처음 꺼내지게 된다. 이것은 FILO:First In Last Out이기도 한, 결국 완벽한 스택이다. 스택 생성스택을 생성하기 위해서 먼저 java.util.Stack 패키지가 import되야 한다. Import한 후 스택을 생성해보자. 스택 생성1Stack&lt;Type&gt; stacks = new Stack&lt;&gt;(); &lt;Type&gt;에는 해당 스택이 어떤 타입의 데이터를 담을 것인지 지정해주면 된다. 스택 타입12345// 정수 스택!Stack&lt;Integer&gt; stacks = new Stack&lt;&gt;();// 문자열 스택!Stack&lt;String&gt; stacks = new Stack&lt;&gt;(); 스택의 메서드스택에는 총 5가지의 메서드가 있다. push()스택에 데이터를 추가하기 위해서는 push() 메서드를 쓴다. push()1234567891011121314import java.util.Stack;class Main { public static void main(String[] args) { Stack&lt;String&gt; animals= new Stack&lt;&gt;(); // Add elements to Stack animals.push(\"Dog\"); animals.push(\"Horse\"); animals.push(\"Cat\"); System.out.println(\"Stack: \" + animals); }} Console1Stack: [Dog, Horse, Cat] 결과창에서 볼 수 있듯이 가장 먼저 push한 “Dog”가 스택의 맨 처음에 있다. pop()스택의 맨 마지막 요소를 없애기 위해서는 pop() 메서드를 쓴다. 참고로 맨 마지막 요소는 사실 상 스택의 맨 꼭대기에 있는 요소이기 때문에 top이라고 부른다. pop()1234567891011121314151617import java.util.Stack;class Main { public static void main(String[] args) { Stack&lt;String&gt; animals= new Stack&lt;&gt;(); // Add elements to Stack animals.push(\"Dog\"); animals.push(\"Horse\"); animals.push(\"Cat\"); System.out.println(\"Initial Stack: \" + animals); // Remove element stacks String element = animals.pop(); System.out.println(\"Removed Element: \" + element); }} Console12Initial Stack: [Dog, Horse, Cat]Removed Element: Cat peek()스택의 맨 마지막 요소를 보고싶을 땐 peek() 메서드를 쓴다. peek()123456789101112131415161718import java.util.Stack;class Main { public static void main(String[] args) { Stack&lt;String&gt; animals= new Stack&lt;&gt;(); // Add elements to Stack animals.push(\"Dog\"); animals.push(\"Horse\"); animals.push(\"Cat\"); System.out.println(\"Stack: \" + animals); // Access element from the top String element = animals.peek(); System.out.println(\"Element at top: \" + element); }} Console12Stack: [Dog, Horse, Cat]Element at top: Cat search()스택의 내용물은 아는 데, 위치를 알고 싶다면? 그럴 때는 search() 메서드를 쓰자. Search()1234567891011121314151617import java.util.Stack;class Main { public static void main(String[] args) { Stack&lt;String&gt; animals= new Stack&lt;&gt;(); // Add elements to Stack animals.push(\"Dog\"); animals.push(\"Horse\"); animals.push(\"Cat\"); System.out.println(\"Stack: \" + animals); // Search an element int position = animals.search(\"Horse\"); System.out.println(\"Position of Horse: \" + position); }} Console12Stack: [Dog, Horse, Cat]Position of Horse: 2 empty()스택이 비었을까 안비었을까? 확인하려면 empty()를 통해 알아보자. 스택이 비었다면 True, 내용물이 하나라도 있다면 False를 리턴해준다. empty()1234567891011121314151617import java.util.Stack;class Main { public static void main(String[] args) { Stack&lt;String&gt; animals= new Stack&lt;&gt;(); // Add elements to Stack animals.push(\"Dog\"); animals.push(\"Horse\"); animals.push(\"Cat\"); System.out.println(\"Stack: \" + animals); // Check if stack is empty boolean result = animals.empty(); System.out.println(\"Is the stack empty? \" + result); }} Console12Stack: [Dog, Horse, Cat]Is the stack empty? false 다음엔 스택을 이용해서 알고리즘을 풀어볼 예정이다. 기억하자 프링글스! 2020-07-16: 언제 풀어???????ㅠ 작심삼일 반성하자 Reference[Programiz] Java Stack Class[Jenkov Tutorials] Java Stack document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/23/java-stack-basics/"},{"title":"Hexo로 블로그를 만들어봤다","text":"나도 블로그 만들었다!개발 공부를 시작한 이후로 수 많은 기술 블로그들을 접했다. 완전 멋있어!라고 생각했고 내가 만들 일은 없을 거라고 믿었다. 그런데 어느 날 나도 멋져보이고 싶었다! 그래서 호다닥 블로그 만드는 법을 검색해봤다. 플랫폼보통 ‘블로그’라 하면 네이버와 티스토리가 흔히 떠오르겠지만, 내가 생각한 멋진 블로그는 우선 주소창이 ~~.github.io이어야 했다 (단순히 멋있기 때문). 찾아보니 Static Website Generator로 페이지를 생성하고 GitHub Pages에 배포하면 된다고 한다! 근데 또 여기서 고민: 정적 페이지는 뭘로 만들지? 여러가지 정적 사이트 생성기가 있었다. Jekyll Hugo Hexo Gatsby a Ruby generator built by Github for powering their Github pages an extremly fast static generator built on top of the Go programming language a fast website generator based on Node.js a blazing fast static site/PWA generator built around modern web technologies such as React and GraphQL 참고: How to Choose the Right Static Generator: Jekyll vs. Hugo vs. Hexo 근데 이 중에서 내가 고를 수 있는 건 Hexo밖에 없었다. 저기 있는 기술 중 node.js밖에 안써봐서ㅎ 그래도 하나라도 아는 게 어딘가! 그리고 Hexo는 그 중 테마도 예쁜 게 제일 많았다! 나는 예쁜 게 좋은 사람이니 이게 제일 좋았다. Hexo 처음 써본 간략한 후기내 개발실력은 “실력”이라고 할 것도 없고 그냥 이제 막 “개발”에 발가락을 담궈본 수준이다. node.js도 써본 적만 있지 잘 아는 것도 아니었다. 그 상태로 나름 따라해본다고 이것 저것 검색해보고 만든 후, 커스터마이징 하려고 테마 폴더를 열어봤는데 그냥 기절할 뻔했다. 하나도 모르겠어! 흑흑 공부할게 아주 한참 남았구나 싶은 순간이었다. CSS도 나름 자신있다고 생각했는 데 절대 아니었다. 어디서 개발한다고 하지 말아야지…개발은 무슨 응애다. 그래도 어찌저찌 커마는 했다… 결론: 뭔지 모르고 그냥 만들었다 앞으로의 계획사실 이름만 거창하게 기술 블로그지, 아직 남들에게 공유할 만한 기술 스택은 갖춘게 없다. 대신 지금부터라도 꾸준하게 TIL을 기록해보려고 한다. 보여주기 식이라도 꾸준히 쓰면 머릿속에 하나라도 남겠지! 최소한 마크다운은 제대로 알게 되지 않을까?ㅎ 작심삼일이 아니길 기도할 뿐… Reference블로그 만들 때 참고한 자료들:YouTube DesignCourse: The Hexo Static Site (Blog) Generator - Beginner’s Crash Course YouTube 카인드패밀리: 오늘 부터 나도 github.io 블로그 운영자다!! | github pages , goormide, hexo document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/14/i-am-a-newbie-blogger/"},{"title":"[Java] Interface(인터페이스)를 Implement한다는 건","text":"개발을 공부하다 보면 영어 단어를 들리는 그대로 우리말로 옮겨서 사용하는 경우가 많다. 보통 그 단어를 알면 개념을 이해하기 수월한데, (ex. map) 가끔 영어로도 모르는 단어가 있으면 공부하다 너무 헷갈린다. 대표적인 예가 Interface다. 특히 어떤 클래스가 인터페이스를 implement 한다는 게 너무 헷갈려서 정리해본다. Interface란?Interface의 사전적 의미를 살펴보자. 서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점이나 경계면이다. 즉, 사용자가 기기를 쉽게 동작시키는데 도움을 주는 시스템을 의미한다.출처: 위키백과 이 의미를 Java의 Interface에 대입하면 “어떤 객체를 쉽게 구현하기 위해 도와주는 클래스”라고 생각하면 될 것 같다. 흔히 보이는 인터페이스는 어떤 객체와 연관된 메소드들이 모여있는 구조다. 다만, 메소드에 구현부가 없다. Interface Example12345678public interface Bicycle { //method signatures void changeGear(int newValue); void speedUp(int increment); void applyBrakes(int decrement);} 실제로 인터페이스는 상수, method signiture, default method, static method, 중첩 클래스만 가질 수 있다. 앞서 말한 흔한 인터페이스의 구조는 method signature (메소드 이름 + 파라미터)만 가지고 있는 형태다. Java 8부터 default와 static 키워드가 추가되었다. 기존에는 인터페이스에서 메소드가 어떤 기능을 하는지 구구절절 알려주는 구현부를 쓸 수 없었는데 이제부터는 default나 static 키워드로 선언하면 구현부를 써도 된다. Default나 static 메소드는 따로 오버라이딩하지 않아도 사용할 수 있다고 한다! 더 자세한 건 프로그래머스의 설명을 보는 게 좋을 것 같다. 구현부가 없다 보니 인터페이스는 객체화(instantiate) 할 수 없다 (무슨 기능을 해야하는지 안적혀 있으니 당연한 것 같다). 따라서 인터페이스를 사용하려면 다른 클래스가 implement 하거나 extend 해줘야 한다. Implement하다?나는 인터페이스를 implement 한다는 게 제일 헷갈렸다. 내가 아는 implement의 정의는 “실행하다” 밖에 없었기 때문이다. 그러다 찾은 implement의 IT적 의미: To begin to use a new system출처: Cambridge Dictionary 결국 “사용한다”라는 뜻이었다! Implement an Interface어떤 클래스가 인터페이스를 implement하게 되면 그제서야 오버라이딩을 통해 인터페이스에 있는 메소드들을의 구현부를 쓸 수 있게 된다. Implement Interface Example123456789101112131415161718192021class SamChunRiBicycle implements Bicycle { int gear = 1; void changeGear(int newValue) { gear = newValue; } void speedUp(int increment) { speed = speed + increment; } void applyBrakes(int decrement) { speed = speed - decrement; } void printStates() { System.out.println(\"cadence:\" +cadence + \" speed:\" + speed + \" gear:\" + gear); }} 자료형으로써의 인터페이스인터페이스의 가장 큰 목적은 여러 클래스들이 공통 속성을 가질 때 그 속성을 하나의 그룹으로 압축(?)하기 위해서인 것 같다. 이건 List 인터페이스를 보면 이해가 딱 된다. ArrayList, LinkedList, Stack, Vector 모두 클래스인데, List를 implement하고 오버라이딩 해서 공통된 리스트 속성을 가지지만 각자 다른 클래스들이 나오는 것이다!🙌 이래서 인터페이스를 정의한다는 것은 새로운 참조형 (reference data type)을 만드는 것과 같다고 하나보다. ReferenceOracle Java Documentation: What Is an Interface?Oracle Java Documentation: Using an Interface as a TypeJava Api: Interface List document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/01/java-what-does-implement-mean/"},{"title":"[Java] String 비교하기","text":"Java에서 String끼리 비교할 때 ==는 쓰면 안된다고 한다. 의미상으로는 둘 다 “같다”는 뜻인 데, 왜 .equals()는 되고 ==는 안되는 걸까? 그래서 알아보자! String에서 .equals() 와 ==의 차이! Java의 데이터 타입Java에서 Data Type이란 해당 데이터가 메모리에 어떻게 저장되고, 프로그램에서 어떻게 처리되어야 하는지를 알려주는 것이다. 자바에서 타입은 크게 기본형(Primitive) 타입과 참조형(Reference) 타입이 있다. String 생성하기Java에서 가장 흔히 + 많이 쓰이는 참조형 타입은 바로 String(문자열)이다. String을 생성하는 방법은 2가지가 있다. new 연산자로 생성하는 방법 literal로 생성하는 방법 String 생성하기12345//new로 생성String a = new String(\"Hello World!\"); //literal로 생성String b = \"Hello World!\"; 여기서 차이점이 뭘까? 바로 String이 생성되는 메모리의 영역이다. new로 생성하는 Stringnew를 통해 String을 생성하면 Heap영역에 존재하게 된다. 이 경우 내용물은 같아보여도 Heap에 각자 한 부분씩 자리를 잡게 된다. literal로 생성하는 String반대로 literal로 생성할 경우 String Constant Pool이라는 영역에 존재하게 된다 (이 영역도 Heap의 한 부분이긴 하다). “constant = 계속되는”에서 추측할 수 있듯이 이 영역에 있는 String은 계속해서 쓸 수 있다. 쉽게 말해서 재활용할 수 있는 것이다. 예시에서 보면 알 수 있듯이 String c와 String d는 같은 “Hello World!”를 참조한다. .equals() VS ==그렇다면 .equals() 와 ==로 돌아와보자. 이 두 기능의 차이는 뭘까? .equals() : 문자(character)를 비교 == : 변수의 값(=reference)를 비교 결론==의 경우 변수의 값을 비교하는 데, 참조형 타입인 String의 경우 참조하는 주소가 다를 수 있기 때문에 String 끼리 비교했을 때 당연히 값이 다르다고 나올 수 있다. 따라서 String을 비교할 때는 .equals()를 쓰는 게 좋은 것이었다. Reference[Coursera] Data Structures and Performance[Medium Leopold Baik(백중원)] Java String의 메모리에 대한 고찰 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/05/14/java-comparing-strings/"},{"title":"[Python] 비트연산자로 부분집합 구하기","text":"비트연산자 &amp;와 &lt;&lt;를 이용해 이중 for문이라도 빠르게 부분집합을 구해보자! 파이썬으로 부분집합을 구할때 보통 itertools를 사용한다. 하지만 itertools 라이브러리 사용이 불가능한 코테도 있으니(ex. 쌤썽ㅠ)… for 문을 이용해 부분집합을 빠르게 구하는 방법도 알아야한다. 이것은 바로 비트연산자로 계산해서 부분집합을 구하는 방법이다. 먼저 코드부터 보자. Finding out powersets12345678arr = [1,2,3]n = len(arr)for i in range(1 &lt;&lt; n): for j in range(n): if i &amp; (1 &lt;&lt; j): print(arr[j], end=' ') print() 결과1234567891 2 1 2 3 1 3 2 3 1 2 3 Process finished with exit code 0 위의 코드는 주어진 arr 리스트의 부분집합을 모두 출력한다. n은 arr의 길이인 3이다. 이렇게 원소가 3개인 집합의 부분집합들을 구하는 코드를 분석해보자. 이 코드를 이해하기까지 정!말! 오래 걸렸다 😭😭😭 . 다시 봐도 이해할 수 있도록 코드를 한 줄씩 쪼개서 이해한 과정을 남겨본다. 원리이 방식은 2진법을 이용해 부분집합을 알아낸다. 2진법은 두 개의 숫자 0과 1만을 이용해 숫자를 나타내는 방식이다. 이걸 가지고 1은 원소가 포함 된 경우, 0은 원소가 포함되지 않은 경우로 생각한다. 그림과 같이 [1, 2, 3]이라는 숫자 리스트가 있으면 가장 긴 부분집합은 [1, 2, 3]으로, 부분집합의 최대 길이는 주어진 리스트의 길이와 같다. 따라서 각 부분집합을 리스트처럼 생각해서 특정 원소가 있으면 1, 없으면 0으로 표기한다. 이렇게 공집합을 제외한 모든 부분집합들을 2진법으로 나타낸 후, 각 원소의 값을 알아내기 위해서는 기존에 주어진 숫자 리스트의 인덱스를 알아야 한다. 이를 위해서 각 2진법으로 나타낸 각 부분집합의 요소들과 AND(교집합)가 성립하는 인덱스 번호를 알아낸다. 말로 표현하면 어려우니 그림으로 확인하자. 이렇게 교집합이 있는 인덱스 번호들을 알아낸 후, 그 인덱스의 요소를 출력하면 부분집합이 구해지는 것이다. 코드 쪼개기위의 원리를 기반으로 코드를 한 줄씩 살펴보자. for i in range(1 &lt;&lt; n) 먼저 &lt;&lt; 비트 연산자에 대해 알아보자 1 &lt;&lt; n왼쪽의 1을 2진수로 보고, n번 왼쪽으로 shift하라는 뜻이다. 예를 들어 1 &lt;&lt; 3은 2진수 100이 된다. 근데 이렇게 1을 왼쪽으로 shift하고 난 결과는 2^n과 결과가 같다! 원래 부분집합의 총 갯수를 구하는 공식은 2^원소의 갯수다. 여기서 n은 주어진 숫자 리스트의 길이다. 정리하자면 1&lt;&lt;n은 2^n과 같고, 이것은 부분집합의 총 갯수를 구하는 것이다. 부분집합의 총 갯수만큼 for문 돌리기1for i in range(1&lt;&lt;n): 따라서 위의 for문은 부분집합의 모든 case를 확인하겠다는 것이다. for j in range(n)n은 주어진 원소들의 갯수이다. 따라서 0 ~ n-1까지의 숫자들은 길이가 n인 리스트의 인덱스가 된다. n이 3인 예시의 경우, 0, 1, 2를 하나씩 확인하는 for문이 된다. if i &amp; (1 &lt;&lt; j)여기에 나오는 &amp;는 AND를 찾는 비트연산자로, A &amp; B에서 A와 B의 2진수 형태에서 공통된 값을 10진수로 변환해 리턴해준다. &amp;예시12# ex) print(5 &amp; 4) 위의 예시는 4를 리턴해준다. 5의 2진수 형태는 101이고, 4의 2진수 형태는 100이다. 이 두 숫자 사이의 교집합은 100이기 때문에 이것을 10진수로 변환해 4를 리턴해주는 것이다. 핵심코드12if i &amp; (1&lt;&lt;j): print(arr[j], end=' ') 이제 핵심인 코드를 살펴보자. i는 찾으려는 부분집합이고 (이걸 2진수로 변환해서 1,0으로 이뤄진 리스트처럼 생각) j는 리스트의 인덱스 번호다. 찾으려는 부분집합과 현재 인덱스 번호 사이의 교집합이 있다면, 원본 리스트에서 그 인덱스의 요소를 출력하라는 뜻이다. 예를 들어 i=3일 때를 보자. j는 0 ~ 2까지의 숫자다. 핵심코드 풀이1233 &amp; (1&lt;&lt;0) # 011 &amp; 001 = 1 3 &amp; (1&lt;&lt;1) # 011 &amp; 010 = 103 &amp; (1&lt;&lt;2) # 011 &amp; 100 = 0 j가 0, 1인 경우 2진수 1과 10이라는 결과가 나오지만 j가 2인 경우는 교집합이 없기 때문에 0이 나온다. 따라서 j=2인 경우 이외에는 if 조건을 충족하기 때문에 해당 j를 인덱스로 삼아 숫자 리스트에서 값을 꺼내면 찾고자 하는 부분집합의 원소가 나오게 된다! Conclusion이해하는 과정이 너무 힘들었다. 하지만 [1, 2, 3]의 예시에 대해 직접 위의 과정을 손으로 적어본 것을 통해 약간(?) 이해하게 되었다. 이 방법을 깨달은 사람은 누군지 모르겠지만 진짜 천재같다. 비트연산자로 부분집합 구하기12345678arr = [1,2,3]n = len(arr)for i in range(1&lt;&lt;n): for j in range(n): if i &amp; (1&lt;&lt;j): print(arr[j], end=' ') print() document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/10/15/python-bitwise-powersets/"},{"title":"[Python] Memoization(메모이제이션)","text":"재귀함수로 문제를 풀다 보면 재귀를 썼음에도 불가하고 시간초과(!)가 나는 경우들이 있다. 이럴 때 시간을 단축시킬 수 있는 Memoization(메모이제이션)에 대해서 알아보자. Memoization이란?Memoization은 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다. 동적 계획법의 핵심이 되는 기술이다. (출처: 위키백과 메모이제이션) 단어 Memoization만 봐도 Memo화하는 것이라는 걸 알 수 있다. 쉽게 말해 어떤 파라미터 A를 이용한 함수가 호출됐을 때의 output을 메모해뒀다가 나중에 또 A를 이용한 함수의 호출이 있을 때 메모해둔 값을 그대로 불러오는 것이다. 이렇게 되면 A에 대한 연산을 두 번 이상 할 필요가 없어져서 시간이 훅! 줄어들게 된다. 단, 파라미터 A에 대해서 항상 같은 output이 나올 때만 사용할 수 있다. 어떤 함수 func()에 파라미터 A가 입력됐을 때 결과가 B도 되고 C도 되어버리면 나중에 메모해둔 값을 꺼낼 때 A에 대해 B를 꺼내야 할지, C를 꺼내야 할지 알 수 없기 때문이다. Memoization in Python파이썬에서는 이 메모를 하기 위해 딕셔너리를 활용한다. 딕셔너리 데이터 타입을 보면 { key : value }꼴로 저장이 되는 데, key에 함수(파라미터)를 넣고 value에 해당 함수의 output을 넣어주면 된다. 간단하게 memoization을 활용해 팩토리얼을 구하는 법을 알아보자. Factorial Example1234567891011factorial_memo = {}def factorial(n): if n&lt;2: return 1 if n not in factorial_memo: factorial_memo[n] = n * factorial(n-1) return factorial_memo[n]n = 5print(factorial(n)) 위 함수가 동작하는 방법은 아래와 같다. 왼쪽은 시스템 스택, 오른쪽은 메모이제이션을 위해 만들어둔 메모장 딕셔너리다. factorial 메소드에 파라미터 n이 들어오면, 먼저 시스템 스택에 쌓인다.factorial(n)은 memo라는 딕셔너리에 key가 n일 때 value를 n*factorial(n-1)로 저장한다. 이렇게 되면 memo에 있는 n에 대해서는 factorial(n)을 또다시 연산할 필요 없이 그냥 memo에서 해당 key에 대한 value 값만 찾으면 된다. 이미 저장해둔 값만 찾아내면 되니 빨라진다는 건 알겠는 데, 과연 얼마나 빨라질까? 직접 확인해보자! compare factorials1234567891011121314151617181920212223242526# 메모장!factorial_memo = {}# memoization을 이용한 팩토리얼def factorial_with_memo(n): if n&lt;2: return 1 if n not in factorial_memo: factorial_memo[n] = n * factorial_with_memo(n - 1) return factorial_memo[n]# 그냥 팩토리얼def factorial(n): if n &lt; 2: return 1 return n * factorial(n - 1)#####################팩토리얼 100!을 1000번 반복해보기#####################from timeit import *t1 = Timer(\"factorial_with_memo(100)\", \"from __main__ import factorial_with_memo\").timeit(number=1000)t2 = Timer(\"factorial(100)\", \"from __main__ import factorial\").timeit(number=1000)print(t1, \"vs\", t2)# 결과 : 0.0002186 vs 0.017931199999999998# (시간 단위: 초) 위의 코드를 통해 memoization을 쓴 팩토리얼 함수와 그냥 재귀로 만든 팩토리얼 함수의 속도를 비교해봤다. 팩토리얼 100을 1000번 정도 돌리면 걸리는 시간과 연산이 어마어마할 것이다. 하지만 결과를 보면 알겠지만 memoization을 사용하면 아주! 빠른 속도로 값을 알아낼 수가 있다! 😎 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/11/15/python-absolute-basics-of-memoization/"},{"title":"[SWEA] 1204. 최빈수 구하기 with Python","text":"1204. [S/W 문제해결 기본] 1일차 - 최빈수 구하기 1204.최빈수 구하기123456789101112131415161718192021222324252627282930# test case의 횟수만큼 for문을 돌림for i in range(T): # test case 번호 입력받음 n = int(input()) # 점수들 list에 넣음 scores = list(map(int, input().split())) # 가장 많이 나오는 점수를 저장하기 위한 변수 max = 0 # 입력되는 점수의 갯수는 1000개인데 점수의 범위는 0~100이니까 0~100으로 for문을 돌리는게 더 효율적일 것 같았음 for score in range(101): # 특정 점수가 리스트에 없을 때 if scores.count(score) == 0: continue # 그냥 다음 점수로 넘어가자 # 특정 점수가 #개 있고, 그게 현재 최빈수보다 크면 keep elif scores.count(score) &gt; scores.count(max): max = score # 특정 점수가 #개 있는데 현재 최빈수의 갯수랑 똑같으면 더 큰 점수를 keep elif scores.count(score) == scores.count(max): if score&gt;max: max = score # 최빈수 출력 print(f\"#{n} {max}\") document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/07/31/swea-python-1204-ps/"},{"title":"[SWEA] 1284. 수도 요금 경쟁 with Python","text":"1284. 수도 요금 경쟁 1284. 수도 요금 경쟁123456789101112131415T = int(input())# tc만큰 for문 돌리기for tc in range(1, T+1): # 각 input을 map으로 받는다 P, Q, R, S, W = map(int, input().split()) # A = 사용량 * P원 A = W*P # B = R리터 보다 사용량이 적으면 Q원, R리터 보다 사용량이 높으면 Q원 + 초과량*S B = Q if W&lt;R else Q+(W-R)*S print(\"#{} {}\".format(tc, A if A&lt;B else B)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/08/11/swea-python-1284-ps/"},{"title":"[SWEA] 1288. 새로운 불면증 치료법 with Python","text":"1288. 새로운 불면증 치료법 1288. 새로운 불면증 치료법1234567891011121314151617181920212223242526272829303132333435363738T = int(input())for tc in range(1, T+1): # 1) N을 일단 스트링으로 받는다 =&gt; for문 돌리려면 N은 스트링이어야함 N = input() # 2) 0~9까지 확인할 배열 생성 arr = [0 for _ in range(10)] # 3) N은 문자열이니까 계산용 int N을 만들어둔다 intN = int(N) # 4) count는 몇번 양을 세는지 확인할 변수 count = 1 # 5) 0 ~ 9 사이의 숫자가 나타나지 않았다면 = 아직 배열에 0이 있다면 while 0 in arr: # 6) 문자열 N을 가지고 for문을 돌린다 for i in N: if arr[int(i)] &gt; 0: # 만약 이미 나왔다면 그냥 다음걸로 넘어가고 continue else: #아직 안나왔으면 그 숫자 위치에 1 더해주기 arr[int(i)] += 1 # 7) 아직 안끝났다면 count에 1을 더해준다 count += 1 # 8) 그리고 따로 만든 정수N이랑 count를 곱한 후, # for문 돌리기 쉽게 그걸 다시 문자열로 만든다 N = str(intN * count) # 9) while이 끝났으면 마지막 count += 1이 먹힌채로 끝났을 것이다. # 그래서 1을 빼줘야함 count -= 1 # 끝 print('#{} {}'.format(tc, intN*count)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/08/25/swea-python-1288-ps/"},{"title":"[SWEA] 1926. 간단한 369 게임 with Python","text":"1926. 간단한 369게임 접근 방법 1 ~ N까지 str형태로 리스트를 만든다 현재 값에 3, 6, 9가 포함되어있다면: 현재 값에서 3, 6, 9의 갯수를 카운트 ‘-‘ *갯수 출력 369 아니면 그냥 출력 1926. 간단한 369 게임123456789101112131415N = int(input())nList = [str(i) for i in range(1, N+1)]for num in nList: cnt = 0 if '3' in num: cnt += num.count('3') if '6' in num: cnt += num.count('6') if '9' in num: cnt += num.count('9') if cnt &gt; 0: print('-'*cnt, end=' ') else: print(num, end=' ') document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/10/22/swea-python-1926-ps/"},{"title":"[SWEA] 1859. 백만 장자 프로젝트 with Python","text":"1859. 백만 장자 프로젝트 접근 방법 맨 마지막 날은 어쨌든 팔아야하니까 keep한다 (sellingPrice) N-2번째부터 뒤로 for문을 돌린다 (방금 N-1은 keep 했으니까) 하나씩 이동하면서 만약 현재 값이 sellingPrice 보다 작으면 (-현재 값) + sellingPrice를 result에 더해준다 만약 현재 값이 sellingPrice보다 크면 그 값으로 sellingPrice를 갱신해준다 1859. 백만 장자 프로젝트12345678910111213141516T = int(input())for tc in range(1, T+1): N = int(input()) prices = list(map(int, input().split())) sellingPrice = prices[N-1] result = 0 for i in range(N-2, -1, -1): if prices[i] &gt; sellingPrice: sellingPrice = prices[i] else: result += -prices[i] + sellingPrice print('#{} {}'.format(tc, result)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/10/21/swea-python-1859-ps/"},{"title":"[SWEA] 1940. 가랏! RC카! with Python","text":"1940. 가랏! RC카! 이해하느라 오조오억년 걸린 문제…😿 접근 방법 a, b가 있으면 a가 command고 b가 속도 였다ㅠ speed = 0에서 시작하는 기존 속도 a가 1일 때(가속) speed + b 2일 때(감속) speed가 b보다 작으면 speed = 0 아니면 speed - b if가 다 끝난 후 전체 거리에 speed를 더해준다 1940123456789101112131415161718192021222324T = int(input())for tc in range(1, T+1): N = int(input()) total = 0 speed = 0 for i in range(N): commands = list(map(int, input().split())) # 가속일 때 if commands[0] == 1: speed += commands[1] # 감속일 때 elif commands[0] == 2: if speed &lt; commands[1]: speed = 0 else: speed -= commands[1] total += speed print('#{} {}'.format(tc, total)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/11/17/swea-python-1940/"},{"title":"[SWEA] 파이썬 SW 문제해결 기본: List1","text":"[문제링크] 파이썬 SW 문제해결 기본 - LIST1 [4828] min max접근 방법내장 함수인 min, max를 사용하지 않고 직접 구현해서 최소와 최대값을 구하려고 했다. 참고로 임의의 최대값과 최소값은 각각 2147000000와 -2147000000으로 설정했다. 일반적인 int형 변수의 최대값이 대략 2147000000이기 때문이다. 앞으로도 min값과 max값을 임의로 줘야하는 일이 있다면 이 숫자를 사용하려고 한다. mini = 2147000000 maxi = -2147000000 리스트의 내용물을 하나씩 확인한다 (for문) 만약 현재 값이 mini보다 작다면 mini 값을 갱신 만약 현재 값이 maxi보다 크다면 maxi 값을 갱신 min max123456789101112131415161718192021222324252627282930313233343536# min과 max를 찾아서 그 두개의 차를 돌려주는 함수def findMinMax(arr): # 아주! 큰 수와 아주! 작은 수를 최대, 최소값을 담을 변수에 넣는다 mini = 2147000000 maxi = -2147000000 # 입력받은 리스트의 모든 요소를 첫번째부터 마지막까지 하나씩 확인할거다 for num in arr: # 만약 현재 요소가 위에서 설정한 mini보다 작다면 mini의 값을 현재 요소로 바꿔준다 if num &lt; mini: mini = num # 만약 현재 요소가 위에서 설정한 maxi보다 크다면 maxi의 값을 현재 요소로 바꿔준다 elif num &gt; maxi: maxi = num # for문이 다 끝나면 maxi와 mini 값이 나온다 # 두 개의 차를 리턴한다 return maxi-miniT = int(input())for tc in range(1, T+1): # 리스트의 크기 N = int(input()) # 각 숫자를 입력받아서 리스트에 넣어준다 numList = list(map(int, input().split())) # 함수로 최대-최소를 구해서 그걸 result에 넣는다 result = findMinMax(numList) # BAAM 답이 나온다 print('#{} {}'.format(tc, result)) [4831] 전기버스&lt;접근 방법&gt; K 길이의 구간에 대해서 시작(start)과 끝(end)을 먼저 정한다. 끝은 당연히 시작 위치+K다. 끝 위치에 정류장이 있는지 확인하고, 없으면 끝 위치부터 한 칸 앞으로(왼쪽으로) 이동한다. 만약 끝이 앞쪽으로 이동하다가 시작 위치에 다다를 때까지 정류장이 없으면 그 길은 못 가는 길이다. 정류장이 있다면, 충전소 갯수를 카운트 해주고 새로운 시작과 끝 위치를 정한다. 전기버스12345678910111213141516171819202122232425262728293031323334353637383940414243444546T = int(input())for tc in range(1, T+1): # K, N, M을 각자 매핑해서 받는다 K, N, M = map(int, input().split()) # 우선 정류장 위치를 임시 tmp 리스트에 받아두고 tmp = list(map(int, input().split())) # 0 ~ N+1까지 있는 빈 리스트를 만들고 # 정류장 위치를 1로 표시해준다 # ex) [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0] &lt;= 정류장 1, 3, 5, 7, 9 stations = [0]*(N+1) for i in tmp: stations[i] = 1 # print(stations) # 시작위치와 끝 위치를 정해준다 start = 0 end = start + K #끝 위치는 시작+K번째 인덱스가 될 거임 cnt = 0 # 충전횟수를 셀 변수 # 먼저 끝 위치를 확인한다 #정류장의 끝 위치(stations[end])에 정류장이.. # - 있다! =&gt; 충전 + 1, 시작위치 = 현재 끝위치, 끝 위치 다시 시작 +K 로 갱신해줌 # - 없다! =&gt; 끝 위치 - 1 while start &lt; end and end &lt;N: if stations[end] == 1: cnt += 1 start = end end = start+K else: end -= 1 # while문이 끝났는데 end랑 start랑 같다면? # 이러면 start ~ end 구간 내에 정류장이 없어서 충전을 못한거다 # =&gt; 정류장을 못찾아서 end-1 하면서 찾아도 못 찾은 것 # 결론: 구간내 가능한 정류소 없음: cnt = 0 if end == start: cnt = 0 print('#{} {}'.format(tc, cnt)) [4834] 숫자 카드&lt;접근 방법&gt; 특정 카드가 몇개 있는지 알아내기 위해 딕셔너리를 사용한다. 딕셔너리의 key 값에 이미 있는 카드일 때: 해당 key의 value를 꺼낸 후, 거기에 +1을 해준다. 새로운 value를 다시 key에 넣어준다. 딕셔너리에 없는 key일 때: value를 1로 해서 넣어준다. 숫자카드12345678910111213141516171819202122232425262728293031323334T = int(input())for tc in range(1, T+1): N = int(input()) # 카드 리스트를 입력받는다 cards = list(map(int, input())) # 딕셔너리를 만든다 cDict = dict() for card in cards: # 만약 딕셔너리에 카드번호가 있으면 get해서 +1해서 value에 넣어주고 if card in cDict.keys(): val = cDict.get(card) cDict[card] = val + 1 # 딕셔너리 키에 없는 카드번호면 그냥 value에 1을 넣어준다 else: cDict[card] = 1 # 딕셔너리의 value 중 가장 큰 걸 찾아서 key랑 value를 출력한다! # - 만약 큰 값이 다 똑같으면 더 큰 key를 출력한다! maxi = 0 key = 0 for k, v in cDict.items(): if v &gt; maxi: key = k maxi = v elif v == maxi: if k &gt; key: key = k print('#{} {} {}'.format(tc, key, maxi)) [4835] 구간합&lt;접근 방법&gt; 리스트에 대해서 M개씩 합을 구한다. 합들을 따로 모아둔다. 모아둔 합 중에서 최댓값과 최솟값을 찾아서 차이를 알아낸다. 구간합123456789101112131415161718192021222324252627T = int(input())for tc in range(1, T+1): N, M = map(int, input().split()) numList = list(map(int, input().split())) # 합들을 담을 리스트 sums = [] # N-M+1 만큼 for문을 돌린다는 것: # [1, 2, 3, 4]에서 2개씩 합을 구한다고 하면 # 1+2, 2+3, 3+4 이렇게 3개가 나올 수 있다. # 그럼 1,2,3,4 중에서 1, 2, 3까지만 for문이 돌게 된다. # 즉, 4-2+1 번 for문이 도는 것! == N-M+1 for i in range(N-M+1): tmp = 0 # i번째부터 M개를 다 tmp에 더해준다 for j in range(M): tmp += numList[i+j] # 합 리스트에 tmp 값을 넣어준다! sums.append(tmp) # 각각 min max구하기보다 그냥 정렬해서 맨 뒤에꺼에서 맨 앞에꺼를 빼주면 된다 sums = sorted(sums) print('#{} {}'.format(tc, sums[len(sums)-1] - sums[0])) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/10/14/swea-python-ps-list1/"},{"title":"[SWEA] 파이썬 SW 문제해결 기본: List2","text":"[문제링크] 파이썬 SW 문제해결 기본 - LIST2 [4836] 색칠하기접근 방법 먼저 10*10 보드판 생성 p1(왼쪽위), p2(오른쪽아래) 좌표 값 받기 가로: p1[0] ~ p2[0] 세로: p1[0] ~ p2[1] 가로 세로 가지고 for문으로 색칠할 값을 “더해주기” 겹치는 부분 = 빨강+파랑 = 3 보드판에서 겹치는 영역 카운팅하기 참고로 SWEA에서는 sys 라이브러리를 사용할 수 없다 (sys.stdin.readline() 쓸 수 없음). 제출할 때는 input()로 바꿔서 제출했다. 색칠하기123456789101112131415161718192021222324252627282930313233import sysT = int(sys.stdin.readline())for tc in range(1, T+1): # 보드판 입력받기 (0 ~ 9까지) board = [[0]*10 for _ in range(10)] # 색칠 몇개 할건지 입력받기 N = int(sys.stdin.readline()) for i in range(N): # 색칠할 영역 정보를 먼저 리스트로 받는다 tmp = list(map(int, sys.stdin.readline().split())) p1 = (tmp[0], tmp[1]) #왼쪽 위 좌표 p2 = (tmp[2], tmp[3]) #오른쪽 아래 좌표 color = tmp[4] #색칠할 색상 값 # p2[0]을 포함한 영역까지 칠해야하니 +1 for row in range(p1[0], p2[0]+1): for col in range(p1[1], p2[1]+1): # 보드의 해당 위치에 색상으로 더!해!줌 (대체 ㄴㄴ) board[row][col] += color cnt = 0 # 겹치는 영역을 셀 변수 cnt # 보드판을 돌면서 값이 3인 부분이 있으면 cnt+1 for row in range(10): for col in range(10): if board[row][col] == 3: cnt += 1 print('#{} {}'.format(tc, cnt)) [4843] 특별한 정렬접근 방법 주어진 리스트를 정렬한다 (큰거 - 작은거) 결과 리스트에 맨앞, 맨뒤 순서로 넣는다 i번째, N-1-i번째 for문은 5까지만 해도 됨(어짜피 10개만 출력함) 결과리스트 출력하기 특별한 정렬12345678910111213141516171819T = int(input())for tc in range(1, T+1): N = int(input()) numList = list(map(int, input().split())) # 큰거 ~ 작은거 순으로 정렬하기 numList = sorted(numList, reverse=True) # 결과 담을 리스트 result = [] # 어짜피 10개만 출력하니까 5번째 인덱스까지만 돌린다 for i in range(5): result.append(numList[i]) result.append(numList[N-1-i]) print('#{}'.format(tc), end=' ') print(*result) [4837] 부분집합의 합접근 방법 부분집합을 빠르게 구한다 (비트연산자로 부분집합 구하기) 만약 현재 부분집합의 갯수가 N, 합이 K면 cnt+1 부분집합의 합123456789101112131415161718192021T = int(input())for tc in range(1, T+1): # 1 ~ 12까지 있는 리스트 A = list(range(1, 13)) N, K = map(int, input().split()) cnt = 0 for i in range(1 &lt;&lt; len(A)): # 부분집합의 케이스 마다 empty list 생성 currentSet = [] for j in range(len(A)): if i &amp; (1 &lt;&lt; j): currentSet.append(A[j]) # 현재 부분집합의 길이가 N과 같고 합이 K랑 같다면 우리가 찾는 부분집합! if len(currentSet) == N and sum(currentSet) == K: cnt += 1 print('#{} {}'.format(tc, cnt)) [4837] 부분집합의 합접근 방법 시작, 끝, 목표가 주어진다 시작+끝//2 : mid mid가 목표보다 크면 시작위치를 mid로 조정한다 (끝은 그대로 둠) mid가 목표보다 작으면 끝 위치를 mid로 조정한다 목표를 찾기까지 시작/끝 위치를 조정한 횟수를 리턴한다 이진탐색1234567891011121314151617181920212223242526272829def binarySearch(start, end, goal): cnt = 0 while start &lt; end: mid = (start+end)//2 if goal &gt; mid: start = mid cnt += 1 elif goal &lt; mid: end = mid cnt += 1 else: return cntT = int(input())for tc in range(1, T+1): # 전체페이지, A의 목표, B의 목표가 주어진다 P, A, B = map(int, input().split()) # 책은 1페이지부터 시작하니 1부터 시작한다 a, b = binarySearch(1, P, A), binarySearch(1, P, B) # print(a, b) if a &lt; b: print('#{} A'.format(tc)) elif a &gt; b: print('#{} B'.format(tc)) else: print('#{} 0'.format(tc)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/10/20/swea-python-ps-list2/"},{"title":"[SWEA] 파이썬 SW 문제해결 기본: String","text":"[문제링크] 파이썬 SW 문제해결 기본 - String [4864] 문자열 비교접근 방법str2안에 str1이 있는지 확인한다..! 문자열 비교12345678910T = int(input())for tc in range(1, T+1): str1 = input() str2 = input() if str1 in str2: print('#{} 1'.format(tc)) else: print('#{} 0'.format(tc)) [4861] 회문접근 방법 주어진 문자열들을 입력받는다. (가로) 입력 받은 문자열 중 회문이 있는지 확인한다. 만약 이 단계에서 가로 회문이 찾아진다면 바로 끝내면 된다. 가로에서 못찾았다면 세로 회문을 찾는 함수를 돌린다. (세로) 고정된 index값과 M만큼 증가하는 row를 기준으로 세로값들을 임시 배열에 저장한다. 만약 현재의 임시배열이 회문이면 끝낸다. (아니라면 반복) 회문1234567891011121314151617181920212223242526272829303132333435363738394041424344# 세로로 된 회문을 찾는 함수def findVertical(): for i in range(N-M+1): # 임시 리스트 생성 tmp = [] for j in range(N): for k in range(M): tmp.append(board[k+i][j]) # 만약 리스트의 현재 길이가 M이고 회문이라면 종료 if len(tmp) == M and tmp == tmp[::-1]: return tmp # if문에서 종료하지 않았다면 임시 리스트를 비워준다 tmp.clear()T = int(input())for tc in range(1, T+1): N, M = map(int, input().split()) board = [] isDone = False for _ in range(N): #board에 넣기 전 잠시 임시변수에 문자열을 담아둔다 tmp = list(map(str, input())) # 만약 가로 회문이 존재한다면 바로 끝낸다. for i in range(N-M+1): if tmp[i:] == tmp[i:][::-1]: print('#{}'.format(tc), end=' ') print(*tmp[i:], sep='') # for문을 끝내기 위한 flag변수 isDone = True # 가로회문이 존재하지 않아 종료되지 않았다면 세로 변수를 찾아야하니 board에 넣어준다 else: board.append(tmp) # 가로 통과 못했을 때만 세로 확인 if isDone == False: vertical = findVertical() print('#{}'.format(tc), end=' ') print(*vertical, sep='') [4865] 글자수접근 방법 str1을 set으로 받는다 (중복제거) str1애들로 딕셔너리를 만든다 str1의 각 요소에 대해서 str2에 몇개씩 있는지 카운트 후 딕셔너리에 추가한다 딕셔너리의 value중 가장 큰 값을 출력한다 글자수1234567891011121314151617181920T = int(input())for tc in range(1, T+1): #중복 제거를 위해 set으로 받는다 str1 = set(input()) str2 = input() # 중복된 요소를 셀 dictionary countAlpha = {} for alphabet in str2: if alphabet in str1: # 이미 있는 key라면 value+1을 해준다 if alphabet in countAlpha.keys(): value = countAlpha.get(alphabet) countAlpha[alphabet] = value+1 # 없는 key는 value에 1을 넣어준다 else: countAlpha[alphabet] = 1 print('#{} {}'.format(tc, max(countAlpha.values()))) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/10/20/swea-python-ps-string/"},{"title":"[SWEA] 1945. 간단한 소인수분해with Python","text":"1945. 간단한 소인수분해 접근 방법 N을 받는다 2, 3, 5, 7, 11 로 N을 나눠본다 나머지가 0이면 N = N//나눈 수 a, b, c, d, e 중 해당하는 수에 +1 (리스트로 구하기) 19451234567891011121314151617181920212223242526272829303132333435T = int(input())for tc in range(1, T+1): # a, b, c, d, e의 값들을 담을 리스트 result = [0]*5 N = int(input()) # N을 나누고 나눠 1이 될 때까지 반복 # 2~11 중의 숫자로 나눠떨어지면 N값을 갱신하고 # result에서 a~e중 해당되는 인덱스에 1씩 더해준다 while N &gt; 1: if N % 2 == 0: N = N//2 result[0] += 1 if N % 3 == 0: N = N//3 result[1] += 1 if N % 5 == 0: N = N//5 result [2] += 1 if N % 7 == 0: N = N//7 result[3] += 1 if N % 11 == 0: N = N//11 result[4] += 1 print('#{} '.format(tc), end='') print(*result) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/11/18/swea-python-1945/"},{"title":"[SWEA] 1946. 간단한 압축 풀기 with Python","text":"1946. 간단한 압축 풀기 접근 방법 result는 [] alpha, n으로 매핑 받기 n이 10의 배수면 n//10 만큼 alpha*10를 result에 추가해주기 left가 0보다 크면 alpha*left를 result[-1]에 추가 후 n -= left 아니라면 n//10만큼 ‘’에 넣어두고 공백이 얼만큼 남았는지 확인 (=left) 194612345678910111213141516171819202122232425262728T = int(input())for tc in range(1, T+1): N = int(input()) result = [] left = 0 #left = 남은 공백 for _ in range(N): alpha, n = map(str, input().split()) n = int(n) if left &gt; 0: result[-1] += alpha*left n -= left left = 0 if n%10 == 0: for i in range(n//10): result.append(alpha*10) else: for i in range(n//10): result.append(alpha*10) result.append(alpha*(n%10)) left = 10 - (n%10) print('#{}'.format(tc)) print(*result, sep='\\n') document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/11/18/swea-python-1946/"},{"title":"[SWEA] 1954. 달팽이 숫자 with Python","text":"1954. 달팽이 숫자 접근 방법방향: right, down, left, up N * N의 배열을 만든다 반복문: 1 ~ N*N까지 현재 x, y가 유효하면 print(i) 안 유효하면 방향%4로 틀기 195412345678910111213141516171819202122232425dx = [0, 1, 0, -1]dy = [1, 0, -1, 0]T = int(input())for tc in range(1, T+1): N = int(input()) snail = [[0]*N for _ in range(N)] x, y = 0, 0 i = 2 d = 0 snail[x][y] = 1 while i &lt;= N*N: if -1&lt;x+dx[d%4]&lt;N and -1&lt;y+dy[d%4]&lt;N and snail[x+dx[d%4]][y+dy[d%4]] == 0: x = x+dx[d%4] y = y+dy[d%4] snail[x][y] = i i += 1 else: d += 1 print('#{}'.format(tc)) for i in range(N): print(*snail[i]) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/11/18/swea-python-1954/"},{"title":"[SWEA] 1948. 날짜 계산기 with Python","text":"1948. 날짜 계산기 접근 방법 모든 month(key)와 days(value)를 담은 딕셔너리 준비 첫째 달(fm), 첫째 날짜(fd), 둘째 달(sm), 둘째 날짜(sd)를 입력받음 같은 달 일 때 (fm==sm) 둘째 day - 첫째 day + 1 다른 달 일 때 (무조건 두번째 달이 더 큼) 첫 번째 전체day - 첫째 day 1 증가한 달의 day ~ 두번째 달 -1까지 day 두번째 day 위에 세개 합치기 19481234567891011121314151617181920days = { 1:31, 2:28, 3:31, 4:30, 5:31, 6:30, 7:31, 8:31, 9:30, 10:31, 11:30, 12:31}T = int(input())for tc in range(1, T+1): fm, fd, sm, sd = map(int, input().split()) print('#{}'.format(tc), end=' ') if fm == sm: print(sd-fd+1) else: total = days[fm]-fd for month in range(fm+1, sm): total += days[month] total += sd print(total+1) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/11/18/swea-python-1948/"},{"title":"[SWEA] 1959. 두 개의 숫자열 with Python","text":"1959. 두 개의 숫자열 접근 방법 더 긴 쪽 구하기 비교 가능한 횟수 i: long-short+1 for i: short만큼 for loop (j) short[j] * long[i+j] 누적하기 if 현재 누적 &gt; 기존 최대: 기존 최대 갱신 1959123456789101112131415161718192021222324T = int(input())for tc in range(1, T+1): N, M = map(int, input().split()) nList = list(map(int, input().split())) mList = list(map(int, input().split())) maxi = 0 if N &gt; M: for i in range(N-M+1): tmp = 0 for j in range(M): tmp += mList[j] * nList[i+j] if tmp &gt; maxi: maxi = tmp else: for i in range(M - N+1): tmp = 0 for j in range(N): tmp += nList[j] * mList[i + j] if tmp &gt; maxi: maxi = tmp print('#{} {}'.format(tc,maxi)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/11/18/swea-python-1959/"},{"title":"[SWEA] 1961. 숫자 배열 회전 with Python","text":"1961. 숫자 배열 회전 접근 방법 N*N 리스트 입력받기 배열을 입력받아서 90도씩 회전시킨다 회전 시킬 때 새로운 배열을 항상 만든다 (답에서 회전한 모든 결과를 보여야하기 때문) i는 0부터 N까지 증가 &amp; j는 N-1에서 0까지 감소할 때 j번째 row의 N-1-i번째 col에 arr[i][j]값 넣기 19611234567891011121314151617181920def rotate(arr): newArr = [[0]*N for _ in range(N)] for i in range(N): for j in range(N): newArr[j][N-1-i] = arr[i][j] return newArrT = int(input())for tc in range(1, T+1): N = int(input()) arr = [list(map(int, input().split())) for _ in range(N)] a = rotate(arr) b = rotate(a) c = rotate(b) print('#{}'.format(tc)) for i in range(N): print(''.join(map(str,a[i])), ''.join(map(str,b[i])), ''.join(map(str,c[i]))) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/11/25/swea-python-1961/"},{"title":"[SWEA] 1966. 숫자를 정렬하자 with Python","text":"1966. 숫자를 정렬하자 접근 방법 그냥 정렬한다! 라이브러리 만세 1966123456T = int(input())for tc in range(1, T+1): N = int(input()) arr = sorted(list(map(int, input().split()))) print('#{}'.format(tc), end=' ') print(*arr) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/11/25/swea-python-1966/"},{"title":"[SWEA] 1970. 쉬운 거스름돈 with Python","text":"1970. 쉬운 거스름돈 접근 방법 제약사항에 위배되는 input이 많음!2. N의 마지막 자릿수는 항상 0이다. (ex : 32850) &lt;&lt; 이거에 해당되지 않는 input이 아주 많음 👉 그래서 모든 1의 자리 수를 0으로 바꿨다 money: 돈 종류를 모두 담은 리스트 (큰 돈 ~ 작은 돈 순서로 정렬) result: money과 같은 길이의 리스트 (내용물 모두 0) money의 0번째부터 주어진 돈을 나눠봄 나눴을 때 0이라면 안 나눠지는 것 =&gt; i+1 나눠지면 그 나머지가 N이 됨 result[i]에는 몫이 들어감 19701234567891011121314151617181920212223T = int(input())for tc in range(1, T+1): # 거스름돈 N = input() N = int(N[:len(N)-1]+'0') # print(N) money = [50000, 10000, 5000, 1000, 500, 100, 50, 10] result = [0]*len(money) i = 0 while i &lt; len(money) or N &gt; 0: if N // money[i] != 0: result[i] += N//money[i] N = N%money[i] else: i += 1 print('#{} '.format(tc)) print(*result) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/12/02/swea-python-1970/"},{"title":"[SWEA] 1976. 시각 덧셈 with Python","text":"1976. 시각 덧셈 접근 방법 a시 a분, b시 b분 입력받기 a시 + b시 a분 + b분 만약 a분+b분이 60초과라면 시+1, a+b분-60 13시 부터는 다시 12 빼주는거 잊지말기 197612345678910111213141516T = int(input())for tc in range(1, T+1): h1, m1, h2, m2 = map(int, input().split()) hour = h1+h2 if hour &gt; 12: hour -= 12 minutes = m1+m2 if minutes &gt; 60: minutes -= 60 hour += 1 print('#{} {} {}'.format(tc, hour, minutes)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/12/03/swea-python-1976/"},{"title":"[SWEA] 1979. 어디에 단어가 들어갈 수 있을까 with Python","text":"1979. 어디에 단어가 들어갈 수 있을까 접근 방법 함수로 K길이의 1이 나오는지 확인한다 (가능한 공백은 1로 표시됨) 확인할 문자열 check를 만들어둔다 현재 input으로 들어온 줄에서 1이 연속으로 나올 때 check에 넣어줌 만약 K랑 길이가 같으면 cnt+1 197912345678910111213141516171819202122232425262728293031323334353637383940414243def checkK(current): global cnt if Ks in current : check = '' for i in range(N): if check == '': if current[i] == '1': check += '1' else: if current[i] == '1': check += '1' if i == N-1 and len(check) == K: cnt += 1 else: if len(check) == K: cnt += 1 check = '' else: check = ''# T = 1T = int(input())for tc in range(1, T+1): N, K = map(int, input().split()) board = [''.join(input().split()) for _ in range(N)] Ks = '1'*K # 들어갈 수 있는 자리 길이 확인 cnt = 0 # 들어갈 수 있는 자리의 총 갯수 # 가로로 확인하기 for i in range(N): checkK(board[i]) # 세로로 확인하기 for i in range(N): col = '' for j in range(N): col += board[j][i] checkK(col) print('#{} {}'.format(tc,cnt)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/12/03/swea-python-1979/"},{"title":"[SWEA] 1983. 조교의 성적 매기기 with Python","text":"1983. 조교의 성적 매기기 접근 방법 각 학생의 총점을 구해서 순서대로 리스트에 넣는다 인덱스랑 함께 총점 기준으로 정렬한다 N//10으로 정렬한 인덱스를 나눈다 19831234567891011121314151617181920212223grades = ['A+', 'A0', 'A-', 'B+', 'B0', 'B-', 'C+', 'C0', 'C-', 'D0']T = int(input())for tc in range(1, T+1): N, K = map(int, input().split()) scores = [] for i in range(N): mid, fin, hw = map(int, input().split()) scores.append(0.35*mid + 0.45*fin + 0.2*hw) result = [(score, idx+1) for idx, score in enumerate(scores)] result.sort(reverse=True) tmp = N//10 ans = 0 for i in range(N): if result[i][1] == K: ans = i//tmp print('#{} {}'.format(tc,grades[ans])) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/12/03/swea-python-1983/"},{"title":"[SWEA] 1984. 중간 평균값 구하기 with Python","text":"1984. 중간 평균값 구하기 접근 방법 리스트로 받아서 정렬한다 1번과 마지막꺼 뺀 값들의 합을 구한다 합 / 8 = 평균 198412345678T = int(input())for tc in range(1, T+1): nums = sorted(list(map(int, input().split()))) sumV = sum(nums[1:9]) avg = round(sumV/8) print('#{} {}'.format(tc,avg)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/12/03/swea-python-1984/"},{"title":"[SWEA] 1986. 지그재그 숫자 with Python","text":"1986. 지그재그 숫자 접근 방법 1부터 N까지 홀수는 더하고 짝수는 뺀다 19861234567891011T = int(input())for tc in range(1, T+1): N = int(input()) result = 0 for i in range(1, N+1): if i%2: result += i else: result -= i print('#{} {}'.format(tc, result)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/12/04/swea-python-1986/"},{"title":"[SWEA] 2005. 파스칼의 삼각형 with Python","text":"2005. 파스칼의 삼각형 접근 방법 result를 이차원 배열로 만든다 첫째줄은 [1] 그 다음 줄 부터: 바로 앞 리스트에서 두개씩 더해서 현재 리스트에 더해주면 [1, a, b]의 꼴이 나옴 그 뒤에 1을 하나 더 추가해준다 200512345678910111213141516171819T = int(input())for tc in range(1, T+1): N = int(input()) result = [[1]] for i in range(1, N): row = [1] for j in range(len(result[-1])-1): sumV = 0 for k in range(2): sumV += result[-1][j+k] row.append(sumV) row.append(1) result.append(row) print('#{}'.format(tc)) for i in range(len(result)): print(*result[i]) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/12/05/swea-python-2005/"},{"title":"[SWEA] 2001. 파리 퇴치 with Python","text":"2001. 파리 퇴치 접근 방법 가로/세로로 M*M의 합을 확인하기 위해 이동할 수 있는 횟수 = N-M+1 0 ~ N-M+1까지 이동하면서 그 안에서 M*M으로 이중for문을 돌린다 M*M의 합이 현재 있는 최대합보다 크면 최대합 갱신해주기 200112345678910111213141516T = int(input())for tc in range(1, T+1): N, M = map(int, input().split()) square = [list(map(int, input().split())) for _ in range(N)] maxi = 0 for i in range(N-M+1): for j in range(N-M+1): current = 0 for k in range(M): for l in range(M): current += square[j+l][i+k] if current &gt; maxi: maxi = current print('#{} {}'.format(tc, maxi)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/12/05/swea-python-2001/"},{"title":"[SWEA] 2007. 패턴 마디의 길이 with Python","text":"2007. 패턴 마디의 길이 접근 방법 받은 문자열에서 길이가 1~10인 가능한 패턴을 모두 찾아서 리스트에 넣어준다 패턴 리스트에서 for문을 돌리며 현재 있는 패턴이 반복되는 패턴이 맞는지 확인한다 2007123456789101112131415161718T = int(input())for tc in range(1, T+1): string = input() pList = [] for i in range(1, 11): pList.append(string[:i]) ans = 10 for i in range(10): tmp = len(pList[i]) if string[:tmp] == string[tmp:2 * tmp]: if tmp &lt; ans: ans = tmp break print('#{} {}'.format(tc, ans)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/12/06/swea-python-2007/"},{"title":"[SWEA] 1989. 초심자의 회문 검사 with Python","text":"1989. 초심자의 회문 검사 접근 방법 단어를 str으로 받아서 뒤집은거랑 똑같은지 확인한다 같으면 1, 아니면 0 출력 1989123456789T = int(input())for tc in range(1, T+1): word = input() if word == word[::-1]: print('#{} {}'.format(tc, 1)) else: print('#{} {}'.format(tc, 0)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/12/04/swea-python-1989/"},{"title":"[Git] cherry-pick으로 원하는 commit 가져오기","text":"최근 새롭게 알고리즘 스터디를 꾸리게 되면서 git의 cherry-pick 기능을 써보게 되었다. git은 add, commit, push 명령어만 아는 git알못이었는데, 스터디 덕분에 새로운 git잘알에 한 발자국 다가가게 된 것 같다. 나도 git잘알이 되고 싶어서 정리해본 cherry-pick! cherry-pick? 무슨 뜻이람git의 명령어들은 영어다. 다행히 난 영문학과 출신이다. cherry-pick 두 단어를 보니 체리를 고른다는 뜻 같다. 이게 뭐람? A metaphor, from the idea of picking through a bowl of cherries and seeking the best for oneself, or the idea of picking off the cherries for oneself from a cake or dessert.1 찾아보니 체리 한 바구니에서 제일 좋은 체리만 고르는 것에서 유래한 표현이라고 한다. git에서만 쓰는 표현인 줄 알았는데 알고 보니 그냥 동사였다. 일반적으로는 제일 좋은 걸 선별한다는 뜻으로 쓰인다고 한다. 영어공부도 하고 git 공부도 하고 진짜 일석이조다. 자, 그렇다면 git에서 제일 좋은 것만 고른다는 건 무슨 뜻일까? git cherry-pickgit cherry-pick 명령어는 git log에서 특정한 commit 하나만 콕 찝어서 현재 HEAD가 가리키는 branch에 추가할 수 있게 해준다. 쉽게 말해서 다른 branch에 있는 commit을 지금 내 branch에 가져와서 commit 할 수 있는 것이다. 참고로 commit을 branch에서 다른 branch로 옮기는 건 아니고, 전체 history를 따지면 새로운 commit이 늘어나는 것이다. cherry-pick은 언제 써야 할까유용하긴 하지만 cherry-pick이 항상 권장되는 것은 아니라고 한다. 같은 commit이 여러 번 쌓이는 일도 발생할 수 있기 때문에 cherry-picking이 가능한 상황에서 보통은 일반적인 merge를 사용하는 걸 선호한다고 한다.2 그렇다면 cherry-pick은 어떤 상황에서 유용할까? 예시 상황을 생각해 보자. 팀으로 협업할 때친구랑 사이드 프로젝트를 진행하고 있다. 나는 백엔드다. 현재 내가 맡은 기능이 프론트까지 더해졌을 때 어떻게 돌아가는지 확인하고 싶은데 프론트엔드를 맡은 친구가 지금 한창 작업 중이라고 한다. 아까 CSS 파일을 완성해서 commit해 뒀다고 한다. 그럼 난 cherry-pick을 통해 그 commit 하나만 찾아서 내 branch에 가져오면 된다. 오 CSS만 입혀볼 수 있게 됐다. 버그 수정나는 며칠 전 A 기능을 완성한 개발자다. A가 끝나고 B 기능을 개발하는 중이었는데, 알고 보니 A 기능에 버그가 있다고 한다. 더 많은 유저들이 이 버그로 인한 현상을 겪기 전에 빠르게 버그 패치를 해서 내 branch에 commit한다. 내가 방금 commit한 이 패치는 git cherry-pick을 통해 main branch에 바로 반영되었다. 휴 문제 해결. 반영되지 않은 pr실수로 pull request를 merge하기 전에 닫아버렸다. 당황하지 않고 git cherry-pick을 통해 해당 commit을 가져옴으로써 살릴 수 있게 됐다. 알고리즘 스터디이건 실제 나의 경우인데, 알고리즘 스터디를 하며 스터디원들의 코드를 올리는 repository에서 main branch에서 모두의 코드를 push하는 것보다 각자의 branch를 만들어서 각각 올리는 방식을 선택했다. 우리는 주어진 같은 문제를 풀어오는 것을 원칙으로 하기 때문에 각 문제별 폴더를 main에서 생성하면 cherry-pick을 통해 폴더를 생성한 commit만 각자 branch로 따온다. cherry-pick 사용법가져오고 싶은 commit의 이름 확인하기1git log git log 명령어를 통해 내가 cherry-pick하고자 하는 commit의 이름을 확인한다. 내가 찾는 commit의 Hash 값을 복사한다. 예시에선 abc123이라고 적어뒀다. cherry-pick으로 추가하려는 branch로 이동1git checkout &lt;branch name&gt; cherry-pick 진행1git cherry-pick abc123 끝! 잘 commit되었는지 확인하려면 git log를 통해 내 branch의 commit 내역을 보면 된다. Reference1 Wikipedia: cherry-pick2 Bitbucket: Git Cherry Pickcherry-pick의 사전적 의미(Merriam Webster)Stack overflow: What does cherry-picking a commit with Git mean? document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/12/10/git-cherry-pick-basics/"}],"tags":[{"name":"Git","slug":"git","link":"/tags/git/"},{"name":"GitHub","slug":"github","link":"/tags/github/"},{"name":"TIL","slug":"til","link":"/tags/til/"},{"name":"Java","slug":"java","link":"/tags/java/"},{"name":"Data Structure","slug":"data-structure","link":"/tags/data-structure/"},{"name":"Life","slug":"life","link":"/tags/life/"},{"name":"Blog","slug":"blog","link":"/tags/blog/"},{"name":"Hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Java 101","slug":"java-101","link":"/tags/java-101/"},{"name":"Python","slug":"python","link":"/tags/python/"},{"name":"Algorithm","slug":"algorithm","link":"/tags/algorithm/"}],"categories":[{"name":"Java","slug":"java","link":"/categories/java/"},{"name":"Life","slug":"life","link":"/categories/life/"},{"name":"Python","slug":"python","link":"/categories/python/"},{"name":"Data Structure","slug":"java/data-structure","link":"/categories/java/data-structure/"},{"name":"Java 101","slug":"java/java-101","link":"/categories/java/java-101/"},{"name":"SWEA","slug":"python/swea","link":"/categories/python/swea/"},{"name":"Algorithm","slug":"python/algorithm","link":"/categories/python/algorithm/"},{"name":"Git","slug":"git","link":"/categories/git/"}]}