{"pages":[{"title":"about","text":"TESTINGGGThis is cool🎉 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"}],"posts":[{"title":"Spring의 DI","text":"Dependency Injection (의존성 주입)스프링에서 의존성 주입이란, 말 그대로 필요한 객체를 주입한다는 뜻이다. 좀 더 쉽게 살펴보기 위해 건전지를 넣어야하는 장난감을 예제로 들어보자. 장난감이 작동하기 위해서는 배터리가 필수다. 다시 말해 장난감이 배터리에 의존하기 때문에 배터리를 장난감에 주입해야 한다. 먼저 건전지를 분리할 수 없는 배터리 일체형 장난감을 생각해보자. 123456789public class ElectricToyCar { private Battery battery; public ElectricToyCar() { battery = new Battery(); //공장에서 장난감을 만들 때 배터리를 주입한 상태로 만든다! }} 위의 코드와 같이 배터리 일체형 장난감은 생성자에서 배터리를 주입하게 되고, 이외에는 배터리를 주입할 수 있는 방법이 없다. 반대로 건전지를 분리할 수 있는 분리형 장난감을 생각해보자. 1234567891011121314public class ElectricToyRadio { private Battery battery; public ElectricToyRadio(Battery battery) { this.battery = battery; //공장에서 장난감을 만들 때 기본적으로 배터리를 하나 넣어줌 } public void setBattery(Battery battery) { this.battery = battery; //생성 후 setter를 통해서 배터리 주입 가능! }} 위와 같이 배터리 분리형은 배터리가 다 떨어졌을 때 배터리만 따로 교체하면 된다. 이렇게 필요한 객체를 주입하는 것을 DI, 의존성 주입이라고 한다. 스프링에서 DI 설정 방법 생성자를 이용한 DI123public StudentRegisterService(StudentDao studentDao) { this.studentDao = studentDao; } &lt;constructor-arg ref=\"BEAN NAME\"/&gt; tag로 생성자에 다른 bean을 refer하게 만든다. 1234&lt;bean id= \"studentDao\" class = \"ems.member.dao.StudentDao\" &gt;&lt;/bean&gt;&lt;bean id= \"registerService\" class = \"ems.member.service.StudentRegisterService\"&gt; &lt;constructor-arg ref= \"studentDao\" &gt;&lt;/constructor-arg&gt;&lt;/bean&gt; construct-arg : 생성자 ref: 주입할 객체 아이디 setter를 이용한 DI1234567891011public void setJdbcUrl(String jdbcUrl) { this.jdbcUrl = jdbcUrl; } public void setUserId(String userId) { this.userId = userId; }public void setUserPw(String userPw) { this.userPw = userPw; } &lt;property&gt; tag의 name과 value를 통해 특정 setter를 지정해서 사용한다. 1234&lt;bean id= \"dataBaseConnectionInfoDev\" class = \"ems.member.DataBaseConnectionInfo\" &gt; &lt;property name= \"jdbcUrl\" value = \"jdbc:oracle:thin:@localhost:1521:xe\" /&gt; &lt;property name= \"userId\" value = \"scott\" /&gt; &lt;property name= \"userPw\" value = \"tiger\" /&gt; &lt;/bean&gt; name: setter에서 쓰는 이름 가져오기 (소문자로 시작!) value: 파라미터로 들어오는 값 적어주기 List타입의 DI123public void setDevelopers(List&lt;String&gt; developers) { this.developers = developers; } &lt;list&gt; tag를 통해 값들을 지정해준다.123456789&lt;property name= \"developers\" &gt; &lt;list&gt; &lt;value&gt;Cheney.&lt;/value&gt; &lt;value&gt;Eloy.&lt;/value&gt; &lt;value&gt;Jasper.&lt;/value&gt; &lt;value&gt;Dillon.&lt;/value&gt; &lt;value&gt;Kian.&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; value: list 안에 들어있는 값 Map타입의 DI123public void setAdministrators(Map&lt;String, String&gt; administrators) { this.administrators = administrators; } &lt;map&gt; –&gt; &lt;entry&gt; –&gt; &lt;key&gt; tag를 통해 값들을 지정해준다.12345678910111213141516&lt;property name= \"administrators\" &gt; &lt;map&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;Cheney&lt;/value&gt; &lt;/key&gt; &lt;value&gt;cheney@springPjt.org&lt;/value&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;Jasper&lt;/value&gt; &lt;/key&gt; &lt;value&gt;jasper@springPjt.org&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; Reference[인프런] 자바 스프링 프레임워크 강의 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/20/Spring-DI/"},{"title":"Java HashMap","text":"Java HashMapArrays store items as an ordered collection and in order to access the items an index number (int type) is needed. A HashMap however, stores items in key/value pairs and you can access the value using the key. The &lt; &gt; notation tells the type of object used as keys and values. ExampleCreate a HashMap object called capitalCities that will store String keys and Integer values: 123import java.util.HashMap; // import the HashMap classHashMap&lt;String, String&gt; capitalCities = new HashMap&lt;String, String&gt;(); ### Add Items To add items, use the `put()` method: 12345678capitalCities.put(\"Korea\", \"Seoul\");capitalCities.put(\"Poland\", \"Warsaw\");capitalCities.put(\"Germany\", \"Berlin\");System.out.println(capitalCities);//RESULT{Korea=Seoul, Poland=Warsaw, Germany=Berlin} Access an ItemTo access a value in the HashMap, use the get() method and refer to its key: 12345String city = capitalCities.get(\"Korea\");System.out.println(city);//RESULTSeoul Remove an ItemTo remove an item, use the remove() method and refer to its key: 12345capitalCities.remove(\"Germany\");System.out.println(capitalCities);//RESULT{Korea=Seoul, Poland=Warsaw} To remove ALL ITEMS, use the clear() method: 12345capitalCities.clear();System.out.println(capitalCities);//RESULT{} HashMap SizeTo find out how many items there are, use the size() method: 12345int size = capitalCities.size();System.out.println(size);//RESULT3 Loop Through a HashMapLoop through the items with a for-each loop.Note: use the keySet() method for keys, and use the values() method for values: 1234567for (String s : capitalCities.keySet()) { // process each key in turn }for (String s : capitalCities.values()) { // process each value in turn } Loop Through to FIND a keyCheck if the HashMap includes a given key with containsKey() method: 12345boolean USA = capitalCities.containsKey(\"USA\");System.out.println(USA);//RESULTfalse ReferenceDuke Learn to Program: Java Documentationw3schools.com document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/18/Java-HashMap/"},{"title":"Spring 의존객체 자동주입","text":"의존객체 자동 주입의존객체 자동 주입이란, Spring 2.5부터 생긴 기능으로 &lt;constructor-arg&gt; 또는 &lt;property&gt; 등의 태그로 의존 대상 객체를 명시하지 않아도 스프링 컨테이너가 자동으로 필요한 의존 대상 객체를 찾아서 객체가 필요한 객체에 주입해주는 기능이다. 구현할 때는 @Autowired 와 @Resource 어노테이션을 이용한다. @Autowired@Autowired는 스프링 컨테이너에 있는 Bean 중 타입이 일치하는 Bean을 자동으로 주입해준다. 사용하기 위해서는 다음의 두 가지만 적어주면 된다. 자동 주입 대상에 @Autowired 어노테이션 사용 XML 파일에 &lt;context:annotation-config/&gt; 추가 예시를 살펴보면 다음과 같다. 12345678910public class WordRegisterService { private WordDao wordDao; @Autowired public wordRegisterService(WordDao wordDao) { this.wordDao = wordDao; } ...} 이렇게 Service 클래스의 생성자에 @Autowired를 달아주면, xml 파일에서 타입이 WordDao인 Bean을 찾아서 생성자에 자동으로 주입해준다. 123456...&lt;context:annotaion-config /&gt;&lt;bean id=\"wordDao\" class=\"com.word.dao.WordDao\"/&gt; //이걸 주입한다!&lt;bean id=\"registerService\" class=\"com.word.service.WordRegisterService\"/&gt;&lt;bean id=\"searchService\" class=\"com.word.service.WordSearchService\"/&gt; 참고로 이렇게 생성자에 @Autowired 어노테이션을 쓰는 것은 상관이 없지만, 다른 메소드에 쓰기 위해서는 기본 생성자가 필수다. @Resource@Resource 어노테이션은 스프링 컨테이너에 있는 Bean 중에서 이름이 일치하는 Bean을 찾아서 주입해준다. 다만 @Autowired와는 달리 property나 메소드에만 사용이 가능하다. 그렇기 때문에 기본 생성자가 필수다 (객체가 일단 생성이 돼야 주입이든 뭐든 할 수 있다). 12345678910111213public class WordRegisterService { @Resource private WordDao wordDao; //기본 생성자 public wordRegisterService() { } public wordRegisterService(WordDao wordDao) { this.wordDao = wordDao; } ...} 위와 같이 @Resource를 달아주면 xml 파일에서 이름이 wordDao인 Bean을 찾게 된다. 123456...&lt;context:annotaion-config /&gt;&lt;bean id=\"wordDao\" class=\"com.word.dao.WordDao\"/&gt; //id가 wordDao = 이름 일치!... 의존 객체 선택@Autowired 어노테이션은 타입이 일치하는 Bean을 자동 주입한다고 배웠다. 근데 만약 동일한 타입을 가진 Bean이 두 개 이상이라면 @Autowired 어노테이션은 어떻게 작동할까? 당연히 어떤 Bean을 주입해야하는 지 알 수 없어서 Exception이 발생한다. 이럴 때는 @Qualifier 어노테이션을 이용해 특정 Bean을 지정해줄 수 있다. @Qualifier@Qualifier 어노테이션을 사용하기 위해서는 두 가지를 해주면 된다. XMl 파일에 &lt;qualifier value=\"valueName\"&gt;를 통해 특정 이름 정해주기 @Autowired 밑에 @Qualifier(\"valueName\") 적어주기 XML파일12345&lt;bean id=\"wordDao1\" class=\"com.word.dao.WordDao\"&gt; &lt;qualifier value=\"usedDao\"/&gt;&lt;/bean&gt;&lt;bean id=\"wordDao2\" class=\"com.word.dao.WordDao\"/&gt; &lt;bean id=\"wordDao3\" class=\"com.word.dao.WordDao\"/&gt; XML 파일에 wordDao타입이 3개 정도 있다. 여기서 특정 Bean에 &lt;qualifier&gt; 태그를 통해 \"usedDao\"라는 이름을 정해주면 이 이름을 가진 bean을 자동 주입하게 된다. Service 클래스1234567891011public class WordRegisterService { private WordDao wordDao; @Autowired @Qualifier(\"usedDao\") public wordRegisterService(WordDao wordDao) { this.wordDao = wordDao; } ...} Reference[Baeldung] Guide to Spring @Autowired[인프런] 자바 스프링 프레임워크 강의 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/23/Spring-Auto-DI/"},{"title":"Hexo로 블로그를 만들어봤다","text":"나도 블로그 만들었다!개발 공부를 시작한 이후로 수 많은 기술 블로그들을 접했다. 완전 멋있어!라고 생각했고 내가 만들 일은 없을 거라고 믿었다. 그런데 어느 날 나도 멋져보이고 싶었다! 그래서 호다닥 블로그 만드는 법을 검색해봤다. 플랫폼보통 ‘블로그’라 하면 네이버와 티스토리가 흔히 떠오르겠지만, 내가 생각한 멋진 블로그는 우선 주소창이 ~~.github.io이어야 했다 (단순히 멋있기 때문). 찾아보니 Static Website Generator로 페이지를 생성하고 GitHub Pages에 배포하면 된다고 한다! 근데 또 여기서 고민: 정적 페이지는 뭘로 만들지? 여러가지 정적 사이트 생성기가 있었다. Jekyll Hugo Hexo Gatsby a Ruby generator built by Github for powering their Github pages an extremly fast static generator built on top of the Go programming language a fast website generator based on Node.js a blazing fast static site/PWA generator built around modern web technologies such as React and GraphQL 참고: How to Choose the Right Static Generator: Jekyll vs. Hugo vs. Hexo 근데 이ㅣ중에서 내가 고를 수 있는 건 Hexo밖에 없었다. 저기 있는 기술 중 node.js밖에 안써봐서ㅎ 그래도 하나라도 아는 게 어딘가! 그리고 Hexo는 그 중 테마도 예쁜 게 제일 많았다! 나는 예쁜 게 좋은 사람이니 이게 제일 좋았다. Hexo 처음 써본 간략한 후기내 개발실력은 “실력”이라고 할 것도 없고 그냥 이제 막 “개발”에 발가락을 담궈본 수준이다. node.js도 써본 적만 있지 잘 아는 것도 아니었다. 그 상태로 나름 따라해본다고 이것 저것 검색해보고 만든 후, 커스터마이징 하려고 테마 폴더를 열어봤는데 그냥 기절할 뻔했다. 하나도 모르겠어! 흑흑 공부할게 아주 한참 남았구나 싶은 순간이었다. CSS도 나름 자신있다고 생각했는 데 절대 아니었다. 어디서 개발한다고 하지 말아야지…개발은 무슨 응애다. 그래도 어찌저찌 커마는 했다… 결론: 뭔지 모르고 그냥 만들었다 앞으로의 계획사실 이름만 거창하게 기술 블로그지, 아직 남들에게 공유할 만한 기술 스택은 갖춘게 없다. 대신 지금부터라도 꾸준하게 TIL을 기록해보려고 한다. 보여주기 식이라도 꾸준히 쓰면 머릿속에 하나라도 남겠지! 최소한 마크다운은 제대로 알게 되지 않을까?ㅎ 작심삼일이 아니길 기도할 뿐… Reference블로그 만들 때 참고한 자료들:YouTube DesignCourse: The Hexo Static Site (Blog) Generator - Beginner’s Crash Course YouTube 카인드패밀리: 오늘 부터 나도 github.io 블로그 운영자다!! | github pages , goormide, hexo document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/14/I-made-a-blog-with-hexo/"},{"title":"Spring Framework 개요","text":"Spring FrameworkSpring Framework는 Java 어플리케이션을 쉽고 빠르게 개발할 수 있도록 도와주는 오픈 소스 프레임워크다. 스프링은 lightweight = 경량 프레임워크로, Java 어플리케이션을 개발할 때 필요한 다양한 모듈을 제공한다. 여기서 모듈이란 프로그램을 구성하는 구성 요소다. 기계에서 부품이라고 생각하면 될 것 같다.어떤 프로그램을 기능별로 나눈 후, 그 기능들을 다른 프로그램에 쓸 수 있다 = 모듈! 스프링에서 제공하는 모듈: Modules Features spring-core 스프링의 핵심인 DI(Dependcy Injection)와 IoC (Inversion of Control) 제공 spring-aop AOP 구현 기능 제공 spring-jdbc DB를 쉽게 다룰 수 있는 기능 제공 spring-tx 스프링에서 제공하는 트랜잭션 관련 기능 제공 spring-webmvc 스프링에서 제공하는 Controller와 View를 이용한 SpringMVC 구현 기능 제공 프로젝트에 필요한 모듈들은 원격 어딘가의 라이브러리에 저장돼있다. pom.xml파일에 필요한 모듈을 적으면 저 멀리 원격 repository에 있는 라이브러리가 알아서 프로젝트에 다운된다! pom.xml pom.xml 파일 작성 후 Maven &gt; Update Project를 실행하면 Maven Dependencies 폴더 안에 관련 모듈들이 알맞은 버전으로 생긴다. Spring IoC Container스프링 프레임워크에는 컨테이너가 하나 있다. 바로 객체를 생성하고 조립하는 컨테이너로 편하게 스프링 컨테이너라고 부르고, 여기서 생성된 객체를 Bean이라고 부른다. 왜 Bean일까?처음 스프링을 공부했을 때부터 항상 궁금했다. 왜 그동안은 object나 instance라고 부르다가 갑자기 bean일까?? 구글링을 백번해도 나오지 않는 Bean이라는 단어의 유래…내 추측은 콩 껍질 안에 콩이 여러개 있는 모양이 스프링 프레임워크의 구조와 비슷해서 그렇게 지었나 싶다. 그럼 Container나 BeanFactory가 아니라 Pod여야하는 것 아닌가? 알 수 없군… Bean을 만드는 순서는: applicationContext.xml에 property등을 적어 bean을 만든다. 스프링 컨테이너에서 bean을 생성하고 조립한다. 필요한 bean을 가져다 써서 어플리케이션을 구현한다. ApplicationContext.xml이 파일이 바로 Bean을 만들어주는 스프링 컨테이너다. 원래 객체를 생성할 때 New를 통해서 객체를 메모리에 로딩시킨다. 하지만 xml 파일로 Bean을 생성하면 메모리 어딘가에 스프링 컨테이너가 있고, 그곳에서 Bean이 생성되는 것이다. Bean을 사용하는 방법생성된 Bean을 사용하는 법은 꽤 간단하다. GenericXmlApplicationContext를 통해 어떤 xml을 사용할지 알려준다. .getBean()을 통해 컨테이너에서 생성된 Bean 중 어떤 Bean을 가져올지 알려준다. Bean을 사용한다. xml 파일을 통해 가져온 Bean은 외부 자원이니 반납해준다. ReferenceSpring Framework for Beginners[인프런] 자바 스프링 프레임워크 강의 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/19/Spring-Framework/"}],"tags":[{"name":"TIL","slug":"TIL","link":"/tags/TIL/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Life","slug":"Life","link":"/tags/Life/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"}],"categories":[{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Life","slug":"Life","link":"/categories/Life/"}]}